# 42_MINISHELL
As beautiful as a shell

# Minishell Project Overview

## Objective
The goal of this project is to develop a minimalistic shell that can interpret and execute commands, similar to a Unix shell. This includes handling basic shell features like command execution, redirection, pipelines, and some built-in commands (e.g., `cd`, `echo`, `exit`).

## High-Level Architecture
The minishell consists of three main components:
1. **Lexer** (Lexical Analyzer)
2. **Parser** (Syntax Analyzer)
3. **Executor** (Execution Engine)

## Flow of Command Processing

### 1. Input Handling
The shell reads a line of input from the user. This input is usually a command or a sequence of commands separated by special characters (like `|`, `>`, `<`).

### 2. Lexer (Lexical Analysis)
- **Purpose:** The lexer breaks down the raw input string into a series of tokens. Tokens are the smallest units of meaningful text, such as commands, arguments, and operators.
- **How It Works:**
  - Scans the input string character by character.
  - Groups characters into tokens based on predefined rules. For instance, in the input `ls -l | grep "txt"`, `ls`, `-l`, and `|` are distinct tokens.
  - Handles quotation marks, escape sequences, and environment variable expansion.

### 3. Parser (Syntax Analysis)
- **Purpose:** The parser takes the list of tokens generated by the lexer and organizes them into a data structure that reflects the syntactic structure of the command(s).
- **How It Works:**
  - Analyzes the sequence of tokens to understand the relationships between them.
  - Checks for syntactic correctness and handles the order of operations.
  - Creates a hierarchical structure representing commands, arguments, and operators.

### 4. Executor (Execution Engine)
- **Purpose:** The executor is responsible for taking the parsed structure and executing the commands in the correct order.
- **How It Works:**
  - Traverses the Linked List and executes the commands.
  - Handles:
    - **Command Execution:** Running external programs like `ls`, `grep`, etc.
    - **Built-in Commands:** Handling commands that are part of the shell itself (e.g., `cd`, `echo`, `exit`).
    - **Redirections:** Redirecting input/output as specified (e.g., `>`, `<`).
    - **Pipelines:** Managing commands connected via pipes (e.g., `|`).
  - Manages processes and handles signals
- **Output:** Execution results, which could be output to the terminal, written to files, or passed to other commands via pipes.

## Challenges
- **Error Handling:** Managing syntax errors, command errors, and other edge cases.
- **Efficiency:** Handling multiple commands efficiently, especially with pipelines and redirections.
- **Process Management:** Managing processes, handling signals, and ensuring proper cleanup of resources.
